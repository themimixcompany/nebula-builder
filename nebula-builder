#!/usr/bin/env bash

set -eu
set -o pipefail

readonly SELF=$(basename "${BASH_SOURCE[0]}")
readonly OS=$(uname)
readonly VERSION=0.0.7

OPT_HELP=
OPT_DEBUG=
OPT_VERBOSE=

readonly OPT_BASE_NAME="Nebula"

readonly OPT_ELECTRON=git@github.com:themimixcompany/nebula.git
readonly OPT_VIEWER=git@github.com:themimixcompany/local-world.git
readonly OPT_ENGINE=git@github.com:themimixcompany/engine.git

OPT_TEMP_DIR=

OPT_ENGINE_LINUX=engine_unix_X64
OPT_ENGINE_WINDOWS=engine_windows_X64.exe
OPT_ENGINE_MACOS=engine_macos_X64

OPT_ARCHS=
OPT_BUILD_DIR=
OPT_SOURCES=
OPT_RELEASES=
OPT_TOKEN=
OPT_TAG=

function error () {
  if [[ "${OS}" == "Darwin" ]]; then
    echo "error: ${@}" >&2
  else
    echo -e "\e[0;31m\e[1merror: \e[0;0m${@}" >&2
  fi

  exit 1
}

function warn () {
  if [[ "${OS}" == "Darwin" ]]; then
    echo "warning: ${@}" >&2
  else
    echo -e "\e[0;33mwarning: \e[0;0m${@}" >&2
  fi
}

function debug () {
  if [[ -n "${OPT_DEBUG}" ]]; then
    echo '**'
    echo \${@}: ${@}
    echo \$OPT_HELP: "${OPT_HELP}"
    echo \$OPT_DEBUG: "${OPT_DEBUG}"
    echo \$OPT_VERBOSE: "${OPT_VERBOSE}"
  fi
}

function parse_arguments () {
  debug parse_arguments "$@"

  local opts=$(getopt -n "${SELF}" --options hdva:b:s:r:t:T: --longoptions help,debug,verbose,archs:,build-dir:,sources:,releases:,token:,tag: -- "$@")

  if [[ $? != 0 ]]; then
    error "Failed to parse arguments. Exiting."
  fi

  eval set -- "${opts}"

  while true; do
    case "$1" in
      (-h|--help) OPT_HELP=true; shift ;;
      (-d|--debug) OPT_DEBUG=true; shift ;;
      (-v|--verbose) OPT_VERBOSE=true; shift ;;
      (-a|--archs) OPT_ARCHS=$2; shift 2 ;;
      (-b|--build-dir) OPT_BUILD_DIR=$2; shift 2 ;;
      (-s|--sources) OPT_SOURCES=$2; shift 2 ;;
      (-r|--releases) OPT_RELEASES=$2; shift 2 ;;
      (-t|--token) OPT_TOKEN=$2; shift 2 ;;
      (-T|--tag) OPT_TAG=$2; shift 2 ;;
      (--) shift; break ;;
      (*) break ;;
    esac
  done
}

function process_arguments () {
  debug process_arguments "$@"

  if [[ -n "${OPT_HELP}" || "${#}" -lt 1 ]]; then
    display_usage
  elif [[ -z "${OPT_ARCHS}" || -z "${OPT_BUILD_DIR}" ||
            -z "${OPT_SOURCES}" || -z "${OPT_RELEASES}" ||
            -z "${OPT_TAG}" ]]; then
    display_usage
  else
    return 0
  fi
}

function display_usage () {
  debug display_usage "$@"

  cat << EOF
${SELF} [OPTIONS]... <COMMAND> [OPTIONS]...

OPTIONS:
  -h, --help       Show this help

COMMANDS:
  -a, --archs      Comma-separated list of target architectures (default: ${OPT_ARCHS})
  -b, --build-dir  Location for internal building (default: ${OPT_BUILD_DIR})
  -s, --sources    Location where to get the dependencies (default: ${OPT_SOURCES})
  -r, --releases   Location where to create the releases (default: ${OPT_RELEASES})
  -t, --token      The GitHub authentication token (default: none)
  -T, --tag        The name/version of a release (default: none)
EOF
  exit 0
}

function ensure_directories () {
  debug ensure_directories "$@"

  mkdir -p "${OPT_BUILD_DIR}"
  mkdir -p "${OPT_RELEASES}"
}

function remove () {
  debug remove "$@"

  if [[ -e "$@" ]]; then
    rm -rv "$@"
  fi
}

function move () {
  debug move "$@"

  mv -v "$@"
}

function fetch_remote_sources () {
  debug fetch_remote_sources "$@"

  /opt/bin/ssh-run "git clone $OPT_ELECTRON $OPT_BUILD_DIR/nebula"
  /opt/bin/ssh-run "git clone $OPT_VIEWER $OPT_BUILD_DIR/nebula/app/viewer"
}

function fetch_local_sources () {
  debug fetch_local_sources "$@"

  git clone ${OPT_SOURCES}/nebula ${OPT_BUILD_DIR}/nebula
  git clone ${OPT_SOURCES}/local-world ${OPT_BUILD_DIR}/nebula/app/viewer
}

function fetch_remote_engine_sources () {
  debug fetch_remote_engine_sources "$@"

  /opt/bin/ssh-run "git clone $OPT_ENGINE /root/common-lisp/engine"
}

function build_engine () {
  debug build_engine "$@"

  sbcl --eval '(ql:quickload :engine)' \
       --eval '(engine:build #P"/var/lib/build/nebula/app/engine/")'
}

function create_temp_dir () {
  debug create_temp_dir "$@"

  OPT_TEMP_DIR=$(mktemp -d)
}

function fetch_remote_engine_binaries () {
  debug fetch_remote_engine_binaries "$@"

  local OIFS=${IFS}
  local dir=${OPT_TEMP_DIR}
  local repo=themimixcompany/engine
  local ver=latest

  cd ${dir}

  if [[ -n "${OPT_ARCHS}" ]]; then
    IFS="," read -ra ARCHS <<< "${OPT_ARCHS}"
    for a in ${ARCHS[@]}; do
      case ${a} in
        linux) TOKEN=${OPT_TOKEN} /opt/bin/fetch ${repo} ${OPT_ENGINE_LINUX} ${ver} ;;
        windows) TOKEN=${OPT_TOKEN} /opt/bin/fetch ${repo} ${OPT_ENGINE_WINDOWS} ${ver} ;;
        macos) TOKEN=${OPT_TOKEN} /opt/bin/fetch ${repo} ${OPT_ENGINE_MACOS} ${ver} ;;
        *) warn "No matching engines found. Skipping."; return 0 ;;
      esac
    done
  else
    warn "No archs specified. Skipping."
  fi

  IFS=${OIFS}
}

function fetch_dependencies () {
  debug fetch_dependencies "$@"

  if [[ "${OPT_SOURCES}" == "github" ]]; then
    fetch_remote_sources
    fetch_remote_engine_binaries
  else
    fetch_local_sources
    fetch_remote_engine_binaries
  fi
}

function build_binaries () {
  debug build_binaries "$@"

  local OIFS=${IFS}
  local engine_dir=${OPT_BUILD_DIR}/nebula/app/engine

  mkdir -p ${engine_dir}
  cd $OPT_BUILD_DIR/nebula

  npm install

  if [[ -n "${OPT_ARCHS}" ]]; then
    IFS="," read -ra ARCHS <<< "${OPT_ARCHS}"

    for a in ${ARCHS[@]}; do
      case ${a} in
        linux)
          cp -v ${OPT_TEMP_DIR}/${OPT_ENGINE_LINUX} ${engine_dir}
          chmod +x ${engine_dir}/${OPT_ENGINE_LINUX}
          electron-packager . --platform=linux --out=out --icon=assets/icons/icon.png --prune=true
          electron-builder --linux --prepackaged out/${OPT_BASE_NAME}-linux-x64
          remove ${engine_dir}/${OPT_ENGINE_LINUX}
          ;;
        windows)
          cp -v ${OPT_TEMP_DIR}/${OPT_ENGINE_WINDOWS} ${engine_dir}
          chmod +x ${engine_dir}/${OPT_ENGINE_WINDOWS}
          electron-packager . --platform=win32 --out=out --icon=assets/icons/icon.ico --prune=true
          electron-builder --windows --prepackaged out/${OPT_BASE_NAME}-win32-x64
          remove ${engine_dir}/${OPT_ENGINE_WINDOWS}
          ;;
        macos)
          cp -v ${OPT_TEMP_DIR}/${OPT_ENGINE_MACOS} ${engine_dir}
          chmod +x ${engine_dir}/${OPT_ENGINE_MACOS}
          electron-packager . --platform=darwin --out=out --icon=assets/icons/icon.icns --prune=true
          #electron-builder --macos --prepackaged out/${OPT_BASE_NAME}-darwin-x64
          remove ${engine_dir}/${OPT_ENGINE_MACOS}
          ;;
        *) warn "No archs found"; return 1 ;;
      esac
    done
  else
    warn "No archs specified. Skipping."
  fi

  IFS=${OIFS}
}

function create_arch_releases () {
  debug create_arch_releases "$@"

  local OIFS=${IFS}
  local out_source=${OPT_BUILD_DIR}/nebula/out
  local path=

  if [[ -n "${OPT_ARCHS}" ]]; then
    IFS="," read -ra ARCHS <<< "${OPT_ARCHS}"
    for a in ${ARCHS[@]}; do
      case ${a} in
        linux)
          remove ${OPT_RELEASES}/${a}/${OPT_BASE_NAME}/"${OPT_TAG}"
          mkdir -p ${OPT_RELEASES}/${a}/${OPT_BASE_NAME}
          move ${out_source}/${OPT_BASE_NAME}-linux-x64 ${OPT_RELEASES}/${a}/${OPT_BASE_NAME}/"${OPT_TAG}"

          mkdir -p ${OPT_RELEASES}/${a}/${OPT_BASE_NAME}/installers

          if [[ -f ${out_source}/"${OPT_BASE_NAME}-${OPT_TAG}.AppImage" ]]; then
            mv ${out_source}/"${OPT_BASE_NAME}-${OPT_TAG}.AppImage" ${OPT_RELEASES}/${a}/${OPT_BASE_NAME}/installers
          elif [[ -f ${out_source}/"${OPT_BASE_NAME}_${OPT_TAG}_amd64.deb" ]]; then
            mv ${out_source}/"${OPT_BASE_NAME}_${OPT_TAG}_amd64.deb" ${OPT_RELEASES}/${a}/${OPT_BASE_NAME}/installers
          fi
        ;;
        windows)
          remove ${OPT_RELEASES}/${a}/${OPT_BASE_NAME}/"${OPT_TAG}"
          mkdir -p ${OPT_RELEASES}/${a}/${OPT_BASE_NAME}
          move ${out_source}/${OPT_BASE_NAME}-win32-x64 ${OPT_RELEASES}/${a}/${OPT_BASE_NAME}/"${OPT_TAG}"

          mkdir -p ${OPT_RELEASES}/${a}/${OPT_BASE_NAME}/installers

          if [[ -f ${out_source}/"${OPT_BASE_NAME} Setup ${OPT_TAG}.exe" ]]; then
            mv ${out_source}/${out_source}/"${OPT_BASE_NAME} Setup ${OPT_TAG}.exe" ${OPT_RELEASES}/${a}/${OPT_BASE_NAME}/installers
          fi
        ;;
        macos)
          remove ${OPT_RELEASES}/${a}/${OPT_BASE_NAME}/"${OPT_TAG}"
          mkdir -p ${OPT_RELEASES}/${a}/${OPT_BASE_NAME}
          move ${out_source}/${OPT_BASE_NAME}-darwin-x64 ${OPT_RELEASES}/${a}/${OPT_BASE_NAME}/"${OPT_TAG}"

          return 0
        ;;
        *) warn "No archs found"; return 1;;
      esac
    done
  else
    warn "No archs specified. Skipping."
  fi

  IFS=${OIFS}
}

function create_electron_releases () {
  debug create_electron_releases "$@"

  remove ${OPT_RELEASES}/electron/${OPT_BASE_NAME}/"${OPT_TAG}"

  remove ${OPT_BUILD_DIR}/nebula/.git*
  remove ${OPT_BUILD_DIR}/nebula/out

  mkdir -p ${OPT_RELEASES}/electron/${OPT_BASE_NAME}
  move ${OPT_BUILD_DIR}/nebula ${OPT_RELEASES}/electron/${OPT_BASE_NAME}/"${OPT_TAG}"

  move ${OPT_TEMP_DIR}/engine_* ${OPT_RELEASES}/electron/${OPT_BASE_NAME}/"${OPT_TAG}"/app/engine
  chmod +x ${OPT_RELEASES}/electron/${OPT_BASE_NAME}/"${OPT_TAG}"/app/engine/engine_*
}

function create_zip_releases () {
  debug create_zip_releases "$@"

  if [[ -n "${OPT_TAG}" ]]; then
    IFS="," read -ra ARCHS <<< "${OPT_ARCHS}"
    for a in ${ARCHS[@]}; do
      if [[ -d ${OPT_RELEASES}/${a} ]]; then
        mkdir -p ${OPT_RELEASES}/${a}/${OPT_BASE_NAME}/zips
        cd ${OPT_RELEASES}/${a}/${OPT_BASE_NAME}/"${OPT_TAG}"
        remove ../zips/${a}-${OPT_BASE_NAME}-"${OPT_TAG}".zip
        zip -r ../zips/${a}-${OPT_BASE_NAME}-"${OPT_TAG}".zip .
      fi
    done
  else
    error "No tag specified."
  fi

  mkdir -p ${OPT_RELEASES}/electron/${OPT_BASE_NAME}/zips
  cd ${OPT_RELEASES}/electron/${OPT_BASE_NAME}/"${OPT_TAG}"
  remove ../zips/electron-${OPT_BASE_NAME}-"${OPT_TAG}".zip
  zip -r ../zips/electron-${OPT_BASE_NAME}-"${OPT_TAG}".zip .
}

function create_releases () {
  debug create_releases "$@"

  create_arch_releases
  #create_arch_installers
  create_electron_releases
  #create_zip_releases
}

function main () {
  debug main "$@"

  parse_arguments "$@"
  process_arguments "$@"

  ensure_directories
  create_temp_dir
  fetch_dependencies
  build_binaries
  create_releases
}

main "$@"
