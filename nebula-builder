#!/usr/bin/env bash

set -eu
set -o pipefail

readonly SELF=$(basename "${BASH_SOURCE[0]}")
readonly OS=$(uname)
readonly VERSION=1.0.0

OPT_HELP=
OPT_DEBUG=
OPT_VERBOSE=

readonly OPT_BASE_NAME="nebula"
readonly OPT_PRODUCT_NAME="Mimix Nebula"

readonly OPT_ELECTRON=git@github.com:themimixcompany/nebula.git
readonly OPT_WORLD=git@github.com:themimixcompany/local-world.git
readonly OPT_STREAMS=git@github.com:themimixcompany/streams.git

OPT_TEMP_DIR=

OPT_STREAMS_LINUX=streams_unix_X64
OPT_STREAMS_WINDOWS=streams_windows_X64.exe
OPT_STREAMS_MACOS=streams_macos_X64

OPT_TARGETS=
OPT_BUILD_DIR=
OPT_SOURCES=
OPT_RELEASES=
OPT_TOKEN=
OPT_TAG=

function error () {
  if [[ "${OS}" == "Darwin" ]]; then
    echo "error: ${@}" >&2
  else
    echo -e "\e[0;31m\e[1merror: \e[0;0m${@}" >&2
  fi

  exit 1
}

function warn () {
  if [[ "${OS}" == "Darwin" ]]; then
    echo "warning: ${@}" >&2
  else
    echo -e "\e[0;33mwarning: \e[0;0m${@}" >&2
  fi
}

function debug () {
  if [[ -n "${OPT_DEBUG}" ]]; then
    echo '**'
    echo \${@}: ${@}
    echo \$OPT_DEBUG: "${OPT_DEBUG}"
  fi
}

function parse_arguments () {
  debug parse_arguments "$@"

  local opts=$(getopt -n "${SELF}" --options hdvt:b:s:r:o:T: --longoptions help,debug,verbose,targets:,build-dir:,sources:,releases:,token:,tag: -- "$@")

  if [[ $? != 0 ]]; then
    error "Failed to parse arguments. Exiting."
  fi

  eval set -- "${opts}"

  while true; do
    case "$1" in
      (-h|--help) OPT_HELP=true; shift ;;
      (-d|--debug) OPT_DEBUG=true; shift ;;
      (-v|--verbose) OPT_VERBOSE=true; shift ;;
      (-t|--targets) OPT_TARGETS=$2; shift 2 ;;
      (-b|--build-dir) OPT_BUILD_DIR=$2; shift 2 ;;
      (-s|--sources) OPT_SOURCES=$2; shift 2 ;;
      (-r|--releases) OPT_RELEASES=$2; shift 2 ;;
      (-o|--token) OPT_TOKEN=$2; shift 2 ;;
      (-T|--tag) OPT_TAG=$2; shift 2 ;;
      (--) shift; break ;;
      (*) break ;;
    esac
  done
}

function process_arguments () {
  debug process_arguments "$@"

  if [[ -n "${OPT_HELP}" || "${#}" -lt 1 ]]; then
    display_usage
  elif [[ -z "${OPT_TARGETS}" || -z "${OPT_BUILD_DIR}" ||
            -z "${OPT_SOURCES}" || -z "${OPT_RELEASES}" ||
            -z "${OPT_TAG}" ]]; then
    display_usage
  else
    return 0
  fi
}

function display_usage () {
  debug display_usage "$@"

  cat << EOF
${SELF} [OPTIONS]... <COMMAND> [OPTIONS]...

OPTIONS:
  -h, --help       Show this help

COMMANDS:
  -t, --targets    Comma-separated list of targets (default: ${OPT_TARGETS})
  -b, --build-dir  Location for internal building (default: ${OPT_BUILD_DIR})
  -s, --sources    Location where to get the dependencies (default: ${OPT_SOURCES})
  -r, --releases   Location where to create the releases (default: ${OPT_RELEASES})
  -o, --token      The GitHub authentication token (default: none)
  -T, --tag        The name/version of a release (default: none)
EOF
  exit 0
}

function make_directory () {
  debug make_directory "$@"

  mkdir -p "$@"
}

function ensure_directories () {
  debug ensure_directories "$@"

  make_directory "${OPT_BUILD_DIR}"
  make_directory "${OPT_RELEASES}"
}

function remove () {
  debug remove "$@"

  if [[ -e "$@" ]]; then
    rm -rv "$@"
  fi
}

function move () {
  debug move "$@"

  [[ $# == 2 && -e "$1" ]] && mv "$1" "$2"
}

function fetch_remote_sources () {
  debug fetch_remote_sources "$@"

  /opt/bin/ssh-run "git clone $OPT_ELECTRON $OPT_BUILD_DIR/nebula"
  /opt/bin/ssh-run "git clone $OPT_WORLD $OPT_BUILD_DIR/nebula/app/world"
}

function fetch_local_sources () {
  debug fetch_local_sources "$@"

  git clone ${OPT_SOURCES}/nebula ${OPT_BUILD_DIR}/nebula
  git clone ${OPT_SOURCES}/local-world ${OPT_BUILD_DIR}/nebula/app/world
}

function fetch_remote_streams_sources () {
  debug fetch_remote_streams_sources "$@"

  /opt/bin/ssh-run "git clone $OPT_STREAMS /root/common-lisp/streams"
}

function build_streams () {
  debug build_streams "$@"

  sbcl --eval '(ql:quickload :streams)' \
       --eval '(streams:build #P"/var/lib/build/nebula/app/streams/")'
}

function create_temp_dir () {
  debug create_temp_dir "$@"

  OPT_TEMP_DIR=$(mktemp -d)
}

function fetch_remote_streams_binaries () {
  debug fetch_remote_streams_binaries "$@"

  local OIFS=${IFS}
  local dir=${OPT_TEMP_DIR}
  local repo=themimixcompany/streams
  local ver=latest

  IFS="," read -ra TARGETS <<< "${OPT_TARGETS}"

  cd ${dir}

  for a in ${TARGETS[@]}; do
    case ${a} in
      linux) TOKEN=${OPT_TOKEN} /opt/bin/fetch ${repo} ${OPT_STREAMS_LINUX} ${ver} ;;
      windows) TOKEN=${OPT_TOKEN} /opt/bin/fetch ${repo} ${OPT_STREAMS_WINDOWS} ${ver} ;;
      macos) TOKEN=${OPT_TOKEN} /opt/bin/fetch ${repo} ${OPT_STREAMS_MACOS} ${ver} ;;
    esac
  done

  IFS=${OIFS}
}

function fetch_dependencies () {
  debug fetch_dependencies "$@"

  if [[ "${OPT_SOURCES}" == "github" ]]; then
    fetch_remote_sources
    fetch_remote_streams_binaries
  else
    fetch_local_sources
    fetch_remote_streams_binaries
  fi
}

function build_binaries () {
  debug build_binaries "$@"

  local OIFS=${IFS}
  local streams_dir=${OPT_BUILD_DIR}/nebula/app/streams

  make_directory ${streams_dir}
  cd $OPT_BUILD_DIR/nebula

  IFS="," read -ra TARGETS <<< "${OPT_TARGETS}"

  for a in ${TARGETS[@]}; do
    case ${a} in
      linux)
        npm install
        cp -v ${OPT_TEMP_DIR}/${OPT_STREAMS_LINUX} ${streams_dir}
        chmod +x ${streams_dir}/${OPT_STREAMS_LINUX}
        electron-packager . --platform=linux --out=out --icon=assets/icons/icon.png --prune=true
        electron-builder --linux --prepackaged out/"${OPT_PRODUCT_NAME}"-linux-x64
        remove ${streams_dir}/${OPT_STREAMS_LINUX}
        ;;
      windows)
        npm install
        cp -v ${OPT_TEMP_DIR}/${OPT_STREAMS_WINDOWS} ${streams_dir}
        chmod +x ${streams_dir}/${OPT_STREAMS_WINDOWS}
        electron-packager . --platform=win32 --out=out --icon=assets/icons/icon.ico --prune=true
        electron-builder --windows --prepackaged out/"${OPT_PRODUCT_NAME}"-win32-x64
        remove ${streams_dir}/${OPT_STREAMS_WINDOWS}
        ;;
      macos)
        npm install
        cp -v ${OPT_TEMP_DIR}/${OPT_STREAMS_MACOS} ${streams_dir}
        chmod +x ${streams_dir}/${OPT_STREAMS_MACOS}
        electron-packager . --platform=darwin --out=out --icon=assets/icons/icon.icns --prune=true
        #electron-builder --macos --prepackaged out/"${OPT_PRODUCT_NAME}"-darwin-x64
        remove ${streams_dir}/${OPT_STREAMS_MACOS}
        ;;
      electron)
        npm install
        return 0
        ;;
      docker)
        cd ${OPT_BUILD_DIR}/${OPT_BASE_NAME}
        docker build -t ${OPT_BASE_NAME} .
        ;;
      *) warn "No targets found"; return 1 ;;
    esac
  done

  IFS=${OIFS}
}

function build_releases () {
  debug build_releases "$@"

  local OIFS=${IFS}
  local out=${OPT_BUILD_DIR}/nebula/out

  IFS="," read -ra TARGETS <<< "${OPT_TARGETS}"

  for a in ${TARGETS[@]}; do
    case ${a} in
      linux)
        remove ${OPT_RELEASES}/${a}/${OPT_BASE_NAME}/"${OPT_TAG}"
        make_directory ${OPT_RELEASES}/${a}/${OPT_BASE_NAME}/"${OPT_TAG}"
        mv ${out}/"${OPT_PRODUCT_NAME}"-linux-x64 ${OPT_RELEASES}/${a}/${OPT_BASE_NAME}/"${OPT_TAG}"/app

        make_directory ${OPT_RELEASES}/${a}/${OPT_BASE_NAME}/"${OPT_TAG}"/installers
        [[ -f ${out}/"${OPT_PRODUCT_NAME}"-${OPT_TAG}.AppImage" ]] && mv ${out}/"${OPT_PRODUCT_NAME}"-${OPT_TAG}.AppImage" ${OPT_RELEASES}/${a}/${OPT_BASE_NAME}/"${OPT_TAG}"/installers
        [[ -f ${out}/"${OPT_BASE_NAME}_${OPT_TAG}_amd64.deb" ]] && mv ${out}/"${OPT_BASE_NAME}_${OPT_TAG}_amd64.deb" ${OPT_RELEASES}/${a}/${OPT_BASE_NAME}/"${OPT_TAG}"/installers
        ;;
      windows)
        remove ${OPT_RELEASES}/${a}/${OPT_BASE_NAME}/"${OPT_TAG}"
        make_directory ${OPT_RELEASES}/${a}/${OPT_BASE_NAME}/"${OPT_TAG}"
        mv ${out}/"${OPT_PRODUCT_NAME}"-win32-x64 ${OPT_RELEASES}/${a}/${OPT_BASE_NAME}/"${OPT_TAG}"/app

        make_directory ${OPT_RELEASES}/${a}/${OPT_BASE_NAME}/"${OPT_TAG}"/installers
        [[ -f ${out}/"${OPT_BASE_NAME} Setup ${OPT_TAG}.exe" ]] && mv ${out}/"${OPT_BASE_NAME} Setup ${OPT_TAG}.exe" ${OPT_RELEASES}/${a}/${OPT_BASE_NAME}/"${OPT_TAG}"/installers
        ;;
      macos)
        remove ${OPT_RELEASES}/${a}/${OPT_BASE_NAME}/"${OPT_TAG}"
        make_directory ${OPT_RELEASES}/${a}/${OPT_BASE_NAME}/"${OPT_TAG}"
        mv ${out}/"${OPT_PRODUCT_NAME}"-darwin-x64 ${OPT_RELEASES}/${a}/${OPT_BASE_NAME}/"${OPT_TAG}"/app

        ;;
      electron)
        remove ${OPT_RELEASES}/${a}/${OPT_BASE_NAME}/"${OPT_TAG}"

        remove ${OPT_BUILD_DIR}/nebula/.git
        remove ${OPT_BUILD_DIR}/nebula/.gitignore
        remove ${OPT_BUILD_DIR}/nebula/out

        make_directory ${OPT_RELEASES}/${a}/${OPT_BASE_NAME}/"${OPT_TAG}"

        mv ${OPT_BUILD_DIR}/nebula ${OPT_RELEASES}/${a}/${OPT_BASE_NAME}/"${OPT_TAG}"/app

        mv ${OPT_TEMP_DIR}/streams_* ${OPT_RELEASES}/${a}/${OPT_BASE_NAME}/"${OPT_TAG}"/app/app/streams
        chmod +x ${OPT_RELEASES}/${a}/${OPT_BASE_NAME}/"${OPT_TAG}"/app/app/streams/streams_*
        ;;
      docker)
        make_directory ${OPT_RELEASES}/${a}/${OPT_BASE_NAME}/"${OPT_TAG}"/app
        docker save -o ${OPT_RELEASES}/${a}/${OPT_BASE_NAME}/"${OPT_TAG}"/app/${OPT_BASE_NAME}.tar ${OPT_BASE_NAME}
        gzip -vf9 ${OPT_RELEASES}/${a}/${OPT_BASE_NAME}/"${OPT_TAG}"/app/${OPT_BASE_NAME}.tar
        ;;
      *) warn "No targets found"; return 1;;
    esac
  done

  IFS=${OIFS}
}

function main () {
  debug main "$@"

  parse_arguments "$@"
  process_arguments "$@"

  ensure_directories
  create_temp_dir
  fetch_dependencies
  build_binaries
  build_releases
}

main "$@"
