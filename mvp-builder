#!/usr/bin/env bash

set -eu
set -o pipefail

readonly SELF=$(basename "${BASH_SOURCE[0]}")
readonly OS=$(uname)
readonly VERSION=0.0.3

OPT_HELP=
OPT_DEBUG=
OPT_VERBOSE=

OPT_BASE_NAME="mvp"

OPT_ELECTRON=git@github.com:themimixcompany/mvp-electron.git
OPT_VIEWER=git@github.com:themimixcompany/mpv-shell.git
OPT_ENGINE=git@github.com:themimixcompany/engine.git

# OPT_ARCH = "linux" | "win32" | "darwin"
OPT_ARCH="linux"
OPT_ARCHS="linux,win32"

OPT_BUILD_DIR="./build"
OPT_SOURCES="./sources"
OPT_RELEASES="./releases"
OPT_TOKEN=

function error () {
  if [[ "${OS}" == "Darwin" ]]; then
    echo "error: ${@}" >&2
  else
    echo -e "\e[0;31m\e[1merror: \e[0;0m${@}" >&2
  fi

  exit 1
}

function warn () {
  if [[ "${OS}" == "Darwin" ]]; then
    echo "warning: ${@}" >&2
  else
    echo -e "\e[0;33mwarning: \e[0;0m${@}" >&2
  fi
}

function debug () {
  if [[ -n "${OPT_DEBUG}" ]]; then
    echo '**'
    echo \${@}: ${@}
    echo \$OPT_HELP: "${OPT_HELP}"
    echo \$OPT_DEBUG: "${OPT_DEBUG}"
    echo \$OPT_VERBOSE: "${OPT_VERBOSE}"
  fi
}

function parseArguments () {
  debug parseArguments "$@"

  local opts=$(getopt -n "${SELF}" --options hdva:A:b:s:r:t: --longoptions help,debug,verbose,arch:,archs:,build-dir:,sources:,releases:,token: -- "$@")

  if [[ $? != 0 ]]; then
    error "Failed to parse arguments. Exiting."
  fi

  eval set -- "${opts}"

  while true; do
    case "$1" in
      (-h|--help) OPT_HELP=true; shift ;;
      (-d|--debug) OPT_DEBUG=true; shift ;;
      (-v|--verbose) OPT_VERBOSE=true; shift ;;
      (-a|--arch) OPT_ARCH=$2; shift 2 ;;
      (-A|--archs) OPT_ARCHS=$2; shift 2 ;;
      (-b|--build-dir) OPT_BUILD_DIR=$2; shift 2 ;;
      (-s|--sources) OPT_SOURCES=$2; shift 2 ;;
      (-r|--releases) OPT_RELEASES=$2; shift 2 ;;
      (-t|--token) OPT_TOKEN=$2; shift 2 ;;
      (--) shift; break ;;
      (*) break ;;
    esac
  done
}

function processArguments () {
  debug processArguments "$@"

  if [[ -n "${OPT_HELP}" || "${#}" -lt 1 ]]; then
    displayUsage
  else
    return 0
  fi
}

function displayUsage () {
  debug displayUsage "$@"

  cat << EOF
${SELF} [OPTIONS]... <COMMAND> [OPTIONS]...

OPTIONS:
  -h, --help       Show this help

COMMANDS:
  -a, --arch       Target architecure (default: ${OPT_ARCH})
  -A, --archs      Comma-separated list of target architectures (default: ${OPT_ARCHS})
  -b, --build-dir  Location for internal building (default: ${OPT_BUILD_DIR})
  -s, --sources    Location where to get the dependencies (default: ${OPT_SOURCES})
  -r, --releases   Location where to create the releases (default: ${OPT_RELEASES})
  -t, --token      The GitHub authentication token
EOF
  exit 0
}

function ensureDirectories () {
  debug ensureDirectories "$@"

  mkdir -p "$OPT_BUILD_DIR"
}

function fetchRemoteElectronSources () {
  debug fetch_electron_sources "$@"

  /opt/bin/ssh-run "git clone $OPT_ELECTRON $OPT_BUILD_DIR/mvp-electron"
}

function fetchRemoteViewerSources () {
  debug fetch_viewer_sources "$@"

  /opt/bin/ssh-run "git clone $OPT_VIEWER $OPT_BUILD_DIR/mvp-electron/app/viewer"
}

function fetchRemoteEngineSources () {
  debug fetch_engine_sources "$@"

  /opt/bin/ssh-run "git clone $OPT_ENGINE /root/common-lisp/engine"
}

function buildEngine () {
  debug buildEngine "$@"

  sbcl --eval '(ql:quickload :engine)' \
       --eval '(engine:build #P"/var/lib/build/mvp-electron/app/engine/")'
}

function fetchLocalSources () {
  debug fetchLocalSources "$@"

  git clone ${OPT_SOURCES}/mvp-electron ${OPT_BUILD_DIR}/mvp-electron
  git clone ${OPT_SOURCES}/mvp-shell ${OPT_BUILD_DIR}/mvp-electron/app/viewer
}

function fetchRemoteEngineBinaries () {
  debug fetch_engine_binaries "$@"

  local dir=${OPT_BUILD_DIR}/mvp-electron/app/engine

  local repo=themimixcompany/engine
  local ver=latest

  local OIFS=${IFS}

  # Note: save the binary to the correct location as conditionalized by OPT_ARCH(S)
  # Note: should the engine must be saved after the creation of a release?

  mkdir -p ${dir}
  cd ${dir}


  if [[ -n "${OPT_ARCHS}" ]]; then
    IFS="," read -ra ARCHITECTURES <<< "${OPT_ARCHS}"
    for a in ${ARCHITECTURES[@]}; do
      case ${a} in
        linux) TOKEN=${OPT_TOKEN} /opt/bin/fetch ${repo} engine_unix_X64 ${ver} ;;
        win32) TOKEN=${OPT_TOKEN} /opt/bin/fetch ${repo} engine_windows_X64.exe ${ver} ;;
        *) warn "No matching engines found. Skipping."; return 0 ;;
      esac
    done
  elif [[ -n "${OPT_ARCH}" ]]; then
    case ${OPT_ARCH} in
      linux) TOKEN=${OPT_TOKEN} /opt/bin/fetch ${repo} engine_unix_X64 ${ver} ;;
      win32) TOKEN=${OPT_TOKEN} /opt/bin/fetch ${repo} engine_windows_X64.exe ${ver} ;;
      *) warn "No matching engines found. Skipping."; return 0 ;;
    esac
  else
    warn "No archs specified. Skipping."
  fi

  IFS=${OIFS}
}

function fetchDependencies () {
  debug fetchDependencies "$@"

  if [[ "${OPT_SOURCES}" == "github" ]]; then
    #fetchRemoteElectronSources
    #fetchRemoteViewerSources
    #fetchRemoteEngineSources

    #buildEngine
    #fetchRemoteEngineBinaries

    return 0
  else
    fetchLocalSources
    fetchRemoteEngineBinaries
  fi
}

function buildBinaries () {
  debug buildBinaries "$@"
  local OIFS=${IFS}

  cd $OPT_BUILD_DIR/mvp-electron

  # Note: Is this step still necessary?
  npm install

  if [[ -n "${OPT_ARCHS}" ]]; then
    IFS="," read -ra ARCHITECTURES <<< "${OPT_ARCHS}"
    for a in ${ARCHITECTURES[@]}; do
      electron-forge package --platform=${a}
    done
  elif [[ -n "${OPT_ARCH}" ]]; then
    electron-forge package --platform=${OPT_ARCH}
  else
    warn "No archs specified. Skipping."
  fi

  IFS=${OIFS}
}

function createArchReleases () {
  debug createArchReleases "$@"

  # Note: should the releases directory be cleared first?
  # Note: arch could also be conditionalized here
  if [[ -d ${OPT_BUILD_DIR}/mvp-electron/out/${OPT_BASE_NAME}-${OPT_ARCH}-x64 ]]; then
    cp -av ${OPT_BUILD_DIR}/mvp-electron/out/${OPT_BASE_NAME}-${OPT_ARCH}-x64 ${OPT_RELEASES}/${OPT_ARCH}
  else
    error "Release directory not found."
  fi
}

function createDockerReleases () {
  debug createDockerReleases "$@"

  return 0
}

function createReleases () {
  debug createReleases "$@"

  createArchReleases

  # Note: Is this possible to do inside a Docker container?
  createDockerReleases
}

function main () {
  debug main "$@"

  parseArguments "$@"
  processArguments "$@"

  ensureDirectories
  fetchDependencies
  buildBinaries
  createReleases
}

main "$@"
